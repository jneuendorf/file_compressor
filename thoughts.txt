basic idea: use permutations to create sorted bits

problem: worst case number of steps of next_permutations till bits are sorted = n!/((n/2)! * (n/2)!)
that functions increases faster than 2^n which means the number of bits to represent the taken steps needs potentially more bits than n itself.
....just found out...not true :)

anyways...have defined patterns of bits (sorted, reverse sorted, alternating zero last, alternating 1 last, ...) and set bits to indicate what pattern we have.
alternating 0 last: 1010101010101010 (2, 10, 42, 170, 682, ...)
alternating 1 last: 0101010101010101 (1,  5, 21,  85, 341, ...)
this way a lot of steps can be saved to reach a pattern.

patterns should be very easily checkable.

so the worst case should become
numberOfPatterns  *  n!/((n/2)! * (n/2)!)

simplification does make sense here:

n!/((n/2)! * (n/2)!) = ( n*(n-1)*...*(n/2 + 1) ) / ( (n/2)! )



/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

output format:


the resulting file will have the following structure (without paranthesis and '|'):
(patternID|length1|length2)|(patternID|length1|length2)|...

where the number of bits for length(1/2) are either fix or contained in the file name or sth...
according to the pattern length2 might be omitted.

if we had 4 patterns and the sequence length were 16 (2 bytes) each block would be:

sorted patterns:
pp|xxxx|yyyy => 10 bits instead of 16 => 62.5%
id|len1|len2

alternating patterns:
pp|xxxx      => 6 bits instead of 16 => 37.5%
id|offset

if we had 4 patterns and the sequence length were 24 (3 bytes) each block would be:

sorted:
pp|xxxxx|yyyyy => 12 => 50%

alternating:
pp|xxxxx       => 7  => 29.1%


if we had 4 patterns and the sequence length were 32 (4 bytes) each block would be:

sorted:
pp|xxxxx|yyyyy => 12 => 37.5%

alternating:
pp|xxxxx       => 7  => 21.875%

if we had 4 patterns and the sequence length were 64 (8 bytes) each block would be:

sorted:
pp|xxxxx|yyyyy => 12 => 21.875%

alternating:
pp|xxxxx       => 7  => 12.5%


and so forth....this can go pretty low!!



equation:

sorted:
(log2(num_patterns) + 2 * log(num_bits)) / num_bits

alternating:
(log2(num_patterns) + log(num_bits)) / num_bits
