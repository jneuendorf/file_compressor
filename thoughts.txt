basic idea: use permutations to create sorted bits

problem: worst case number of steps of next_permutations till bits are sorted = n!/((n/2)! * (n/2)!)
that functions increases faster than 2^n which means the number of bits to represent the taken steps needs potentially more bits than n itself.
....just found out...not true :)

anyways...have defined patterns of bits (sorted, reverse sorted, alternating zero last, alternating 1 last, ...) and set bits to indicate what pattern we have.
alternating 0 last: 1010101010101010 (2, 10, 42, 170, 682, ...)
alternating 1 last: 0101010101010101 (1,  5, 21,  85, 341, ...)
this way a lot of steps can be saved to reach a pattern.

patterns should be very easily checkable.

so the worst case should become
numberOfPatterns  *  n!/((n/2)! * (n/2)!)

simplification does make sense here:

n!/((n/2)! * (n/2)!) = ( n*(n-1)*...*(n/2 + 1) ) / ( (n/2)! )


the resulting file will have the following structure (without paranthesis and '|'):
(patternID|length1|length2)|(patternID|length1|length2)|...

where the number of bits for length(1/2) are either fix or contained in the file name or sth...
according to the pattern length2 might be omitted.


--------------

next_permutation algorithm

this algorithm generates the next permutation THAT IS DIFFERENT ("11" has no different permutations).

example:
3 chars, 2 equal
001
010
100
(2,3) - (1,2)

4 chars, 2 equal
0011
0101
0110
1010
1001
1100
(2,3) - (3,4) - (1,2) - (3,4) - (2,4)

4 chars, 3 equal
0001
0010
0100
1000


to not generate an identical permutation make exchanges in some pattern but skip an exchange (transposition) if chars equal.


try to begin from the front:
001
try (1,2) -> equal -> next
try (1,3)
100
try(1,4) nope...indices
try(2,1)
010


0011
try (1,2) -> equal
try (1,3)
1001
try (1,4) -> equal
try (2,1)
0101
0110
1010
1100
